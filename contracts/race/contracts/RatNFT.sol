// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title RatNFT
 * @notice Minimal ERC721 NFT for racing rats - metadata stored off-chain
 * @dev Emits event for webhook, metadata generated by API and stored in Blob
 */
contract RatNFT is ERC721Enumerable, Ownable {
    uint256 private _nextTokenId;
    string private _baseTokenURI;

    /// @notice Emitted when a rat is minted (webhook listens to this)
    /// @param to Address that received the NFT
    /// @param tokenId The token ID minted
    /// @param imageIndex Image selection (frontend determines mapping to actual images)
    event RatMinted(
        address indexed to,
        uint256 indexed tokenId,
        uint8 imageIndex
    );

    constructor(
        string memory name_,
        string memory symbol_,
        string memory baseTokenURI_
    ) ERC721(name_, symbol_) Ownable(msg.sender) {
        _nextTokenId = 1; // Start at 1
        _baseTokenURI = baseTokenURI_;
    }

    /**
     * @notice Mint a new rat NFT
     * @param to Address to mint to
     * @param imageIndex Image selection: 0=white, 1=brown, 2=pink
     * @return tokenId The minted token ID
     *
     * Flow:
     * 1. User selects image (white/brown/pink) in UI
     * 2. Frontend calls mint(address, imageIndex)
     * 3. Contract mints → emits RatMinted with imageIndex
     * 4. Webhook catches event → calls /api/rat-mint
     * 5. API uses imageIndex to set imageUrl (/images/white|brown|pink.png)
     * 6. API generates random stats/bloodline/name
     * 7. API uploads metadata.json to Blob Storage
     */
    function mint(address to, uint8 imageIndex) external returns (uint256) {
        require(to != address(0), "Cannot mint to zero address");

        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);

        emit RatMinted(to, tokenId, imageIndex);

        return tokenId;
    }

    /**
     * @notice Owner mint for testing/airdrops
     * @param to Address to mint to
     * @param imageIndex Image selection: 0=white, 1=brown, 2=pink
     * @return tokenId The minted token ID
     */
    function ownerMint(
        address to,
        uint8 imageIndex
    ) external onlyOwner returns (uint256) {
        require(to != address(0), "Cannot mint to zero address");

        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);

        emit RatMinted(to, tokenId, imageIndex);

        return tokenId;
    }

    /**
     * @notice Get all rats owned by an address
     * @param owner Address to query
     */
    function getRatsOfOwner(
        address owner
    ) external view returns (uint256[] memory) {
        uint256 balance = balanceOf(owner);
        uint256[] memory tokenIds = new uint256[](balance);

        for (uint256 i = 0; i < balance; i++) {
            tokenIds[i] = tokenOfOwnerByIndex(owner, i);
        }

        return tokenIds;
    }

    /**
     * @notice Update base URI (Blob Storage base URL)
     * @param baseTokenURI_ New base URI
     */
    function setBaseURI(string memory baseTokenURI_) external onlyOwner {
        _baseTokenURI = baseTokenURI_;
        emit BaseURIUpdated(baseTokenURI_);
    }

    /// @notice Emitted when base URI is updated
    event BaseURIUpdated(string newBaseURI);

    /**
     * @notice Get base URI
     */
    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @notice Get current next token ID (for testing)
     */
    function nextTokenId() external view returns (uint256) {
        return _nextTokenId;
    }
}

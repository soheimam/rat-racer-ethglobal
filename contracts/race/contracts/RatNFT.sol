// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title RatNFT
 * @notice Minimal ERC721 NFT for racing rats - metadata stored off-chain
 * @dev Emits event for webhook, metadata generated by API and stored in Blob
 * @dev Each rat type (imageIndex) can have different payment token and price
 */
contract RatNFT is ERC721Enumerable, Ownable {
    uint256 private _nextTokenId;
    string private _baseTokenURI;

    // Mapping: imageIndex => payment token address
    mapping(uint8 => address) public ratPaymentTokens;

    // Mapping: imageIndex => mint price in that token
    mapping(uint8 => uint256) public ratMintPrices;

    /// @notice Emitted when a rat is minted (webhook listens to this)
    /// @param to Address that received the NFT
    /// @param tokenId The token ID minted
    /// @param imageIndex Image selection (frontend determines mapping to actual images)
    event RatMinted(
        address indexed to,
        uint256 indexed tokenId,
        uint8 imageIndex
    );

    /// @notice Emitted when a rat type's mint configuration is updated
    event RatConfigUpdated(
        uint8 indexed imageIndex,
        address paymentToken,
        uint256 price
    );

    constructor(
        string memory name_,
        string memory symbol_,
        string memory baseTokenURI_,
        address defaultPaymentToken_,
        uint256 defaultMintPrice_
    ) ERC721(name_, symbol_) Ownable(msg.sender) {
        _nextTokenId = 1; // Start at 1
        _baseTokenURI = baseTokenURI_;

        // Set default payment token and price for all rat types (0, 1, 2)
        for (uint8 i = 0; i < 3; i++) {
            ratPaymentTokens[i] = defaultPaymentToken_;
            ratMintPrices[i] = defaultMintPrice_;
        }
    }

    /**
     * @notice Mint a new rat NFT
     * @param to Address to mint to
     * @param imageIndex Image selection: 0=white, 1=brown, 2=pink
     * @return tokenId The minted token ID
     *
     * Flow:
     * 1. User selects image (white/brown/pink) in UI
     * 2. Frontend checks payment token and price for that imageIndex
     * 3. Frontend calls mint(address, imageIndex) with appropriate token approval
     * 4. Contract transfers payment tokens from user and mints NFT
     * 5. Contract emits RatMinted with imageIndex
     * 6. Webhook catches event â†’ calls /api/rat-mint
     * 7. API uses imageIndex to set imageUrl (/images/white|brown|pink.png)
     * 8. API generates random stats/bloodline/name
     * 9. API uploads metadata.json to Blob Storage
     */
    function mint(address to, uint8 imageIndex) external returns (uint256) {
        require(to != address(0), "Cannot mint to zero address");

        address paymentToken = ratPaymentTokens[imageIndex];
        uint256 price = ratMintPrices[imageIndex];

        require(
            paymentToken != address(0),
            "Payment token not configured for this rat type"
        );
        require(price > 0, "Mint price not set for this rat type");

        // Transfer payment tokens from minter to this contract
        require(
            IERC20(paymentToken).transferFrom(msg.sender, address(this), price),
            "Payment token transfer failed"
        );

        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);

        emit RatMinted(to, tokenId, imageIndex);

        return tokenId;
    }

    /**
     * @notice Owner mint for testing/airdrops
     * @param to Address to mint to
     * @param imageIndex Image selection: 0=white, 1=brown, 2=pink
     * @return tokenId The minted token ID
     */
    function ownerMint(
        address to,
        uint8 imageIndex
    ) external onlyOwner returns (uint256) {
        require(to != address(0), "Cannot mint to zero address");

        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);

        emit RatMinted(to, tokenId, imageIndex);

        return tokenId;
    }

    /**
     * @notice Get all rats owned by an address
     * @param owner Address to query
     */
    function getRatsOfOwner(
        address owner
    ) external view returns (uint256[] memory) {
        uint256 balance = balanceOf(owner);
        uint256[] memory tokenIds = new uint256[](balance);

        for (uint256 i = 0; i < balance; i++) {
            tokenIds[i] = tokenOfOwnerByIndex(owner, i);
        }

        return tokenIds;
    }

    /**
     * @notice Update base URI (Blob Storage base URL)
     * @param baseTokenURI_ New base URI
     */
    function setBaseURI(string memory baseTokenURI_) external onlyOwner {
        _baseTokenURI = baseTokenURI_;
        emit BaseURIUpdated(baseTokenURI_);
    }

    /// @notice Emitted when base URI is updated
    event BaseURIUpdated(string newBaseURI);

    /**
     * @notice Get base URI
     */
    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @notice Get current next token ID (for testing)
     */
    function nextTokenId() external view returns (uint256) {
        return _nextTokenId;
    }

    /**
     * @notice Configure payment token and price for a rat type (onlyOwner)
     * @param imageIndex Rat type (0=white, 1=brown, 2=pink)
     * @param paymentToken ERC20 token address for payment
     * @param price Mint price in that token (wei)
     */
    function setRatConfig(
        uint8 imageIndex,
        address paymentToken,
        uint256 price
    ) external onlyOwner {
        require(paymentToken != address(0), "Invalid payment token");
        require(price > 0, "Price must be greater than 0");

        ratPaymentTokens[imageIndex] = paymentToken;
        ratMintPrices[imageIndex] = price;

        emit RatConfigUpdated(imageIndex, paymentToken, price);
    }

    /**
     * @notice Get mint configuration for a rat type
     * @param imageIndex Rat type (0=white, 1=brown, 2=pink)
     * @return paymentToken ERC20 token address for payment
     * @return price Mint price in that token (wei)
     */
    function getRatConfig(
        uint8 imageIndex
    ) external view returns (address paymentToken, uint256 price) {
        return (ratPaymentTokens[imageIndex], ratMintPrices[imageIndex]);
    }

    /**
     * @notice Withdraw accumulated tokens (onlyOwner)
     * @param token ERC20 token address to withdraw
     * @param to Address to withdraw to
     * @param amount Amount to withdraw
     */
    function withdrawTokens(
        address token,
        address to,
        uint256 amount
    ) external onlyOwner {
        require(to != address(0), "Cannot withdraw to zero address");
        require(IERC20(token).transfer(to, amount), "Transfer failed");
    }
}

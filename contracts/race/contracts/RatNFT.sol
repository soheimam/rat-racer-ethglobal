// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title RatNFT
 * @notice Minimal ERC721 NFT for racing rats - metadata stored off-chain
 * @dev Emits event for webhook, metadata generated by API and stored in Blob
 */
contract RatNFT is ERC721Enumerable, Ownable {
    uint256 private _nextTokenId;
    string private _baseTokenURI;
    IERC20 public raceToken;
    uint256 public mintPrice;

    /// @notice Emitted when a rat is minted (webhook listens to this)
    /// @param to Address that received the NFT
    /// @param tokenId The token ID minted
    /// @param imageIndex Image selection (frontend determines mapping to actual images)
    event RatMinted(
        address indexed to,
        uint256 indexed tokenId,
        uint8 imageIndex
    );

    /// @notice Emitted when mint price is updated
    event MintPriceUpdated(uint256 newPrice);

    constructor(
        string memory name_,
        string memory symbol_,
        string memory baseTokenURI_,
        address raceToken_,
        uint256 initialMintPrice_
    ) ERC721(name_, symbol_) Ownable(msg.sender) {
        _nextTokenId = 1; // Start at 1
        _baseTokenURI = baseTokenURI_;
        raceToken = IERC20(raceToken_);
        mintPrice = initialMintPrice_;
    }

    /**
     * @notice Mint a new rat NFT
     * @param to Address to mint to
     * @param imageIndex Image selection: 0=white, 1=brown, 2=pink
     * @return tokenId The minted token ID
     *
     * Flow:
     * 1. User selects image (white/brown/pink) in UI
     * 2. Frontend calls mint(address, imageIndex) with RACE token approval
     * 3. Contract transfers RACE tokens from user and mints NFT
     * 4. Contract emits RatMinted with imageIndex
     * 5. Webhook catches event â†’ calls /api/rat-mint
     * 6. API uses imageIndex to set imageUrl (/images/white|brown|pink.png)
     * 7. API generates random stats/bloodline/name
     * 8. API uploads metadata.json to Blob Storage
     */
    function mint(address to, uint8 imageIndex) external returns (uint256) {
        require(to != address(0), "Cannot mint to zero address");
        require(mintPrice > 0, "Mint price not set");

        // Transfer RACE tokens from minter to this contract
        require(
            raceToken.transferFrom(msg.sender, address(this), mintPrice),
            "RACE token transfer failed"
        );

        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);

        emit RatMinted(to, tokenId, imageIndex);

        return tokenId;
    }

    /**
     * @notice Owner mint for testing/airdrops
     * @param to Address to mint to
     * @param imageIndex Image selection: 0=white, 1=brown, 2=pink
     * @return tokenId The minted token ID
     */
    function ownerMint(
        address to,
        uint8 imageIndex
    ) external onlyOwner returns (uint256) {
        require(to != address(0), "Cannot mint to zero address");

        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);

        emit RatMinted(to, tokenId, imageIndex);

        return tokenId;
    }

    /**
     * @notice Get all rats owned by an address
     * @param owner Address to query
     */
    function getRatsOfOwner(
        address owner
    ) external view returns (uint256[] memory) {
        uint256 balance = balanceOf(owner);
        uint256[] memory tokenIds = new uint256[](balance);

        for (uint256 i = 0; i < balance; i++) {
            tokenIds[i] = tokenOfOwnerByIndex(owner, i);
        }

        return tokenIds;
    }

    /**
     * @notice Update base URI (Blob Storage base URL)
     * @param baseTokenURI_ New base URI
     */
    function setBaseURI(string memory baseTokenURI_) external onlyOwner {
        _baseTokenURI = baseTokenURI_;
        emit BaseURIUpdated(baseTokenURI_);
    }

    /// @notice Emitted when base URI is updated
    event BaseURIUpdated(string newBaseURI);

    /**
     * @notice Get base URI
     */
    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @notice Get current next token ID (for testing)
     */
    function nextTokenId() external view returns (uint256) {
        return _nextTokenId;
    }

    /**
     * @notice Update mint price (onlyOwner)
     * @param newPrice New mint price in RACE tokens (wei)
     */
    function setMintPrice(uint256 newPrice) external onlyOwner {
        mintPrice = newPrice;
        emit MintPriceUpdated(newPrice);
    }

    /**
     * @notice Get current mint price
     * @return Current mint price in RACE tokens (wei)
     */
    function getMintPrice() external view returns (uint256) {
        return mintPrice;
    }

    /**
     * @notice Withdraw accumulated RACE tokens (onlyOwner)
     * @param to Address to withdraw to
     * @param amount Amount to withdraw
     */
    function withdrawRaceTokens(address to, uint256 amount) external onlyOwner {
        require(to != address(0), "Cannot withdraw to zero address");
        require(raceToken.transfer(to, amount), "Transfer failed");
    }
}
